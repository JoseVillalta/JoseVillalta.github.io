<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Yes Way Jose</title><link>https://JoseVillalta.github.io/</link><description>Recent content on Yes Way Jose</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 24 Jul 2023 09:05:00 -0700</lastBuildDate><atom:link href="https://JoseVillalta.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Staff Engineer Path</title><link>https://JoseVillalta.github.io/posts/staff-engineer-path/</link><pubDate>Mon, 24 Jul 2023 09:05:00 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/staff-engineer-path/</guid><description>Book Review: The Staff Engineer&amp;rsquo;s Path by Tanya Reilly Tanya Reilly gives a guide for individual contributor software engineers who wish to grow their career but do not want to become managers. It gives insights about what a staff engineer does, and what you need to do to perform at that level. This is a technology-agnostic book. It gives the reader a high level view of the functional areas that matter.</description></item><item><title>Coroutines for Go</title><link>https://JoseVillalta.github.io/posts/coroutines-for-go/</link><pubDate>Tue, 18 Jul 2023 06:51:45 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/coroutines-for-go/</guid><description>Go Russ Cox put out an article yesteday about adding the abilities to run coroutines in go. Today I learned the difference between a goroutine and a coroutine. Coroutine is a concurrency pattern in which only one runs at a time. Say we have coroutine A and B. B waits while A runs then A yields to B and A waits while B runs. It turns out this is useful in a few scenarios.</description></item><item><title>Learning File Systems</title><link>https://JoseVillalta.github.io/posts/learning-file-systems/</link><pubDate>Sat, 15 Jul 2023 21:21:31 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/learning-file-systems/</guid><description>Lately I have been learning about File Systems from the book &amp;ldquo;Operating Systems. Three Easy Pieces&amp;rdquo; by Remzi Arpaci-Dusseau.
I used to think that I knew how file systems worked because the interface open, read and write is so straight forward, what else could there be to it? But then at work some weird issues come up where some weird behaviour happens, like, du says the disk has space but df says the disk is full, what could make that happen?</description></item><item><title>My Tsundoku Pile</title><link>https://JoseVillalta.github.io/posts/my-tsundoku-pile/</link><pubDate>Sun, 22 Jan 2023 20:02:32 -0800</pubDate><guid>https://JoseVillalta.github.io/posts/my-tsundoku-pile/</guid><description>I&amp;rsquo;m trying to get through all my technical books that I&amp;rsquo;ve adquired, and never gotten around to. Not going to lie, the Knuth books are intimidating. They are actually not that bad to get through, but they are books that I pick up, read a few pages on a specfic project, try to do a problem or two, and that&amp;rsquo;s it.
The other books are less intimidating, more doable, I&amp;rsquo;m pretty sure al but one of these books were lying around the Amazon campus just sitting on shelves.</description></item><item><title>Paper every Day. Day ten: The Unix Timesharing System by Dennis Ritchie and Ken Thompson</title><link>https://JoseVillalta.github.io/posts/day-ten-unix-timesharing/</link><pubDate>Sun, 31 Jul 2022 10:40:30 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/day-ten-unix-timesharing/</guid><description>Link to Paper
This paper, published in July 1974 is remarkable because the design decisions that were made back then by these guys working at Bell Labs on an operating system for the PDP-11 are still relevant.
I am still struggling to create a mental model of the unix file system, the fact that it looks like a single tree with the root at the top while simultaneously you can have multiple devices mounted dates back to these guys at Bell Labs.</description></item><item><title>Paper every day: Day Nine: An Analysis of Linux Scalability to Many Cores</title><link>https://JoseVillalta.github.io/posts/day-nine-linux-scalability/</link><pubDate>Mon, 25 Jul 2022 09:13:41 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/day-nine-linux-scalability/</guid><description>Link to Paper
From the abstract:
&amp;ldquo;This paper analyzes the scalability of seven system applications running on Linux on a 48-core computer&amp;hellip;using mostly standard parallel programming techniques -this paper introduces one new technique sloppy counters these bottlencek can be removed from the kernl or avoided by changing the application slightly&amp;rdquo;
This paper has an excellent system level tutorial on scalability. They explain that you don&amp;rsquo;t get linear increase in performance because in real life applications parallel tasks usually interact, an interaction forces serial execution.</description></item><item><title>Lets Go</title><link>https://JoseVillalta.github.io/posts/lets-go/</link><pubDate>Sun, 24 Jul 2022 21:42:07 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/lets-go/</guid><description>Go I have been writing go since a little after last year. I actually remember hearing about go when it first came out, back then I honestly never thought I&amp;rsquo;d be getting paid to work in it.
Even though I&amp;rsquo;ve been writing code in go for a while, I don&amp;rsquo;t think I know the language in enough depth to consider myself a go expert. I want to change that. So I am going to start writing about go here as a way to &amp;ldquo;learn in public&amp;rdquo; Expect posts on the following topics:</description></item><item><title>Paper every day. Day Eight. Omega: flexible scalable scheduler for large compute clusters</title><link>https://JoseVillalta.github.io/posts/day-eight-omega/</link><pubDate>Sun, 24 Jul 2022 21:30:27 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/day-eight-omega/</guid><description>Omega Link to paper
Omega was the second cluster manager system built by Google. It is Borg&amp;rsquo;s sucessor and it was designed as a happy medium between Borg&amp;rsquo;s centralized scheduler architecture and Mesos&amp;rsquo;s two-level approach where the placement is delegated to the running framework. Omega shares the state of the cluster among leaders and uses optimistic concurrency control (detect when different cluster schedulers are competing for the same resource)
The premise of the whole paper is that a centralized scheduler does not scale well, so there must be a better way to handle scheduling different types of workloads in a fast and conrrect manner.</description></item><item><title>Paper every day. Day Seven: Large-scale cluster management at Google with Borg</title><link>https://JoseVillalta.github.io/posts/day-seven-borg/</link><pubDate>Sat, 23 Jul 2022 18:56:09 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/day-seven-borg/</guid><description>Borg Link to Paper
Borg is the cluster management system that runs hundreds of thousands of jobs at Google, it is the original system, it&amp;rsquo;s sucessor Omega was written as a reaction to the lessons learned from it. Kubernetes is the third system written with the lessons from those two. This paper helped me understand a few things about my own system since we have our own cluster managenet and scheduler system that work a little different but in general do the same job.</description></item><item><title>Paper every day. Day Six: Hints for Computer Design</title><link>https://JoseVillalta.github.io/posts/day-six-hints-computer-design/</link><pubDate>Fri, 22 Jul 2022 08:13:55 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/day-six-hints-computer-design/</guid><description>Link to Paper
This paper was published originally in 1983 by the legendary folks from the Xerox Palo Alto Research Center. The hints and tips should sound familiar but it&amp;rsquo;s interesting to notice the layer the author is talking about, these guys were designing at very low level. The fact that the same rules apply now it&amp;rsquo;s remarkable. It turns out breaking up a system into the right abstraction with a good interface it&amp;rsquo;s rather hard.</description></item><item><title>Paper every day. Day Five: On Designing and Deploying Internet Scale Services</title><link>https://JoseVillalta.github.io/posts/day-five-design-internet-scale/</link><pubDate>Thu, 21 Jul 2022 07:07:19 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/day-five-design-internet-scale/</guid><description>Link to Paper
This paper is a list of recommendations for running a large-scale system that aims to keep quality high and costs low. The author comes from the Windows Live Services Platform but this might as well be read as an Amazon internal guide since I didn&amp;rsquo;t see a thing in this list that we don&amp;rsquo;t do (or aim to do) in AWS. EDIT: Of course all these things sound familiar!</description></item><item><title>Paper every day. Day Four: Harvest, Yield, and Scalable Tolerant Systems</title><link>https://JoseVillalta.github.io/posts/day-four-harvest-yield/</link><pubDate>Wed, 20 Jul 2022 06:28:24 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/day-four-harvest-yield/</guid><description>Link to paper
Today&amp;rsquo;s paper comes thanks to Will Larson this is a recommended paper in his book Elegant Puzzle
This paper builds on the concepts from the the CAP Theorem which essentially says that when it comes to distributed systems you can only have 2 out of these 3 qualities:
Consistency
Avalaibility
Partition Tolerance
Then it introduces two concepts harvest and yield which is interesting because it&amp;rsquo;s not something you usually hear in distributed systems (this is a paper from the &amp;rsquo;90s) and yet I think it&amp;rsquo;s import to know and to think in these terms.</description></item><item><title>Paper every day. Day Three: Container Design Patterns</title><link>https://JoseVillalta.github.io/posts/day-three-container-design-patterns/</link><pubDate>Tue, 19 Jul 2022 07:23:34 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/day-three-container-design-patterns/</guid><description>Day three: Design patterns for container-based distributed systems Link to paper
Containers provide the ability to package, deploy and reuse applications using a natural isolation boundary. Developers can expose application-specific functionality as interfaces as well as more generic hooks for many systems like metrics, health, etc.
In this paper the authors present the readers with two types of container design patterns: Patterns for container in the same machine (Single node) and patterns where the containers are spread out in different machines (multi node)</description></item><item><title>Paper every day. Day Two: Kubernetes</title><link>https://JoseVillalta.github.io/posts/day-two-k8s/</link><pubDate>Mon, 18 Jul 2022 06:33:49 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/day-two-k8s/</guid><description>Welcome to day 2 of my paper-every-day journey. Today we&amp;rsquo;re going to cover Borg, Omega and Kubernetes This paper goes over how Kubernetes, the de-facto, open-source orchestrator of containers was developed using the lessons learned from building Borg and Omega, Google&amp;rsquo;s internal job orchestrator.
Kubernetes is a container orchestration system that aims to make developing and deploying complex distributed systems easier. The Borg and Omega papers are excellent papers on their own right, but this explanation original published in ACM Queue is very insightful.</description></item><item><title>Goal: A Paper Every Day. Day One: Mesos Paper</title><link>https://JoseVillalta.github.io/posts/day-one-paper/</link><pubDate>Sun, 17 Jul 2022 13:04:01 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/day-one-paper/</guid><description>I&amp;rsquo;ve decided to read a research paper each day. I am doing this in order to get better at my craft. I want to be better at designing software and it has been shown in research that the people who are really good at what they do are those that do &amp;ldquo;delibarate practice&amp;rdquo; I am most definitely NOT the best software system designer out there, but talent is overated and I intend to improve my knowledge one day at time.</description></item><item><title>About me</title><link>https://JoseVillalta.github.io/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://JoseVillalta.github.io/about/</guid><description>Life Story I was born in Venezuela and moved to Florida when I was 13, I went to the Marines right after high school. In May 2001 I joined the Florida Guard and Enrolled in Florida Atlantic University. In 2002 I was lucky to marry an amazing woman. Early 2003 I got sent to Iraq, came back from that in March 2004. Late 2005 my oldest girl was born and my life was transformed.</description></item><item><title>New blog!</title><link>https://JoseVillalta.github.io/posts/sample/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://JoseVillalta.github.io/posts/sample/</guid><description>Started a new page to write about tech stuff. Work in Progress</description></item><item><title>Professional Experience and Education</title><link>https://JoseVillalta.github.io/experience/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://JoseVillalta.github.io/experience/</guid><description>Amazon 2018 - present AWS Fargate: Dataplane team. Writing Golang mostly.
Worked on retail site for 2.5 years using the away team model.
Impinj 2014 - 2018 Wrote Ruby on Rails Motorola 2007 - 2014 Low level firmware Co-op Intern at IBM 2005 - 2006 ASIC design model testing Education Master&amp;rsquo;s Degree in Electrical and Computer Engineer from the University of Florida Bachelor&amp;rsquo;s Degree in Computer Engineering from Florida Atlantic University</description></item></channel></rss>