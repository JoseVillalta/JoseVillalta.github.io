<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>A Deep Dive into Network Namespaces in AWS ECS Containers | Yes Way Jose</title>
<meta name="keywords" content="aws, ecs, containers, networking, linux, namespaces">
<meta name="description" content="Ever wondered what happens under the hood when you launch an ECS task with awsvpc networking? Let&#39;s explore how network namespaces are put together when you run containers in ECS Managed Instances.">
<meta name="author" content="Jose Villalta">
<link rel="canonical" href="http://localhost:1313/posts/network-namespaces-ecs-containers/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css" integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.2eadbb982468c11a433a3e291f01326f2ba43f065e256bf792dbd79640a92316.js" integrity="sha256-Lq27mCRowRpDOj4pHwEybyukPwZeJWv3ktvXlkCpIxY="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/network-namespaces-ecs-containers/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Yes Way Jose (Alt + H)">Yes Way Jose</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/experience/" title="CV">
                    <span>CV</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about/" title="About Me">
                    <span>About Me</span>
                </a>
            </li>
            <li>
                <a href="http://joseavillalta.blogspot.com/" title="Personal Blog">
                    <span>Personal Blog</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      A Deep Dive into Network Namespaces in AWS ECS Containers
    </h1>
    <div class="post-description">
      Ever wondered what happens under the hood when you launch an ECS task with awsvpc networking? Let&#39;s explore how network namespaces are put together when you run containers in ECS Managed Instances.
    </div>
    <div class="post-meta">&lt;span title=&#39;2025-10-12 17:12:00 -0700 PDT&#39;&gt;October 12, 2025&lt;/span&gt;&amp;nbsp;Â·&amp;nbsp;Jose Villalta

</div>
  </header> 
  <div class="post-content"><p>What goes into a network namespace? What&rsquo;s a CNI plugin? This blog post explores the contents of a network namespace and then provides links to the open source code that creates and configures namespaces for containarized workloads running on Fargate and ECS Managed Instances.</p>
<h2 id="what-are-network-namespaces-for">What are network namespaces for?<a hidden class="anchor" aria-hidden="true" href="#what-are-network-namespaces-for">#</a></h2>
<p>A Linux namespace is a construct that creates an isolated copy of the networking stack. Namespaces allows multiple ECS tasks to run on the same host with different IP addresses, DNS configurations, and route tables.</p>
<p><img loading="lazy" src="/img/v2-SingleBridge-Page-4.drawio.png" alt="Network Namespaces Overview"  />
</p>
<p>In ECS, when you want to run containerized applications, you create a task that can contain up to 10 containers. All containers within a task share the same network namespace. Each managed instance supports multiple network interfaces (ENIs) attached, task ENIS are provisioned by ECS Control plane at task launch time.</p>
<p>Let&rsquo;s take a look under the hood.</p>
<h2 id="setting-up-the-investigation">Setting Up the Investigation<a hidden class="anchor" aria-hidden="true" href="#setting-up-the-investigation">#</a></h2>
<p>I will launch an EC2 instance using an AMI provisioned with the ECS Managed Instance Agent running on Bottlerocket. This agent runs the same dataplane software that powers production instances. To enable debugging access, I&rsquo;ll create a variant that includes the login and SSM packages, allowing me to connect via the EC2 Serial Console. The instance will launch in EC2 debug mode, which means it won&rsquo;t be managed by the ECS Control Plane but will be fully owned by my account.</p>
<p>The AWS Console shows that I have an EC2 instance with two ENIs attached. I have two private IPs associated with each ENI. <code>10.194.20.168</code> is my task IP and <code>10.184.20.158</code> is the IP address of my host. The primary ENI is listed as Index 0 and the task ENI is listed as Index 1.</p>
<p><img loading="lazy" src="/img/NetworkInterface.png" alt="Network Interface Screenshot"  />
</p>
<h2 id="examining-network-interfaces-from-the-host">Examining Network Interfaces from the Host<a hidden class="anchor" aria-hidden="true" href="#examining-network-interfaces-from-the-host">#</a></h2>
<p>Connecting to the instance as the root user and running <code>ip link show</code> produces the following output:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ip link show
</span></span><span style="display:flex;"><span>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span style="color:#ae81ff">65536</span> qdisc noqueue state UNKNOWN mode DEFAULT group default qlen <span style="color:#ae81ff">1000</span>
</span></span><span style="display:flex;"><span>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span style="display:flex;"><span>2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span style="color:#ae81ff">9001</span> qdisc mq state UP mode DEFAULT group default qlen <span style="color:#ae81ff">1000</span>
</span></span><span style="display:flex;"><span>    link/ether 02:df:6a:de:12:21 brd ff:ff:ff:ff:ff:ff
</span></span><span style="display:flex;"><span>    altname enp0s5
</span></span><span style="display:flex;"><span>    altname ens5
</span></span><span style="display:flex;"><span>4: fargate-bridge: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span style="color:#ae81ff">1500</span> qdisc noqueue state UP mode DEFAULT group default qlen <span style="color:#ae81ff">1000</span>
</span></span><span style="display:flex;"><span>    link/ether 2a:56:f8:7a:ea:8e brd ff:ff:ff:ff:ff:ff
</span></span><span style="display:flex;"><span>5: veth752433c6@if3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span style="color:#ae81ff">1500</span> qdisc noqueue master fargate-bridge state UP mode DEFAULT group default 
</span></span><span style="display:flex;"><span>    link/ether a2:03:66:23:29:82 brd ff:ff:ff:ff:ff:ff link-netns a333f40b6ac74e92b1541fb0a5d76f9e-02ed2d974f29
</span></span></code></pre></div><p>The <code>ip link show</code> command gives you the list of network interfaces in a Linux system. Notice that it only shows one ENI &ldquo;eth0&rdquo; but you don&rsquo;t see the task ENI &ldquo;eth1&rdquo;.</p>
<p>Let&rsquo;s confirm that eth0 is my actual primary ENI by comparing its address with the info from my AWS Console:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>bash-5.2# ip address show
</span></span><span style="display:flex;"><span>1: ...
</span></span><span style="display:flex;"><span>2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span style="color:#ae81ff">9001</span> qdisc mq state UP group default qlen <span style="color:#ae81ff">1000</span>
</span></span><span style="display:flex;"><span>    link/ether 02:df:6a:de:12:21 brd ff:ff:ff:ff:ff:ff
</span></span><span style="display:flex;"><span>    altname enp0s5
</span></span><span style="display:flex;"><span>    altname ens5
</span></span><span style="display:flex;"><span>    inet 10.194.20.158/24 metric <span style="color:#ae81ff">1024</span> brd 10.194.20.255 scope global eth0
</span></span><span style="display:flex;"><span>       valid_lft forever preferred_lft forever
</span></span><span style="display:flex;"><span>    inet6 fe80::df:6aff:fede:1221/64 scope link proto kernel_ll 
</span></span><span style="display:flex;"><span>       valid_lft forever preferred_lft forever
</span></span><span style="display:flex;"><span>       ...
</span></span></code></pre></div><p>Yep, I see that the IP for eth0 is <code>10.194.20.158/24</code> and I see the MAC address matches. I also noticed that eth1 is not visible from the primary network namespaceâas far as the host is concerned there is only one gateway to the internet.</p>
<h2 id="exploring-network-namespaces">Exploring Network Namespaces<a hidden class="anchor" aria-hidden="true" href="#exploring-network-namespaces">#</a></h2>
<p>Let&rsquo;s get a list of the network namespaces running:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>bash-5.2# ip netns show
</span></span><span style="display:flex;"><span>a333f40b6ac74e92b1541fb0a5d76f9e-02ed2d974f29 <span style="color:#f92672">(</span>id: 0<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>bash-5.2# ctr -n fargate.task t ls
</span></span><span style="display:flex;"><span>TASK                                           PID     STATUS    
</span></span><span style="display:flex;"><span>a333f40b6ac74e92b1541fb0a5d76f9e-0883211837    <span style="color:#ae81ff">1551</span>    RUNNING
</span></span><span style="display:flex;"><span>bash-5.2# 
</span></span></code></pre></div><p>The first command <code>ip netns show</code> gives me a list of all the network namespaces. The second command is <code>ctr</code>, a command line client to talk to the containerd daemon. <code>t ls</code> lists all the tasks running in the fargate.task namespace.</p>
<p>Yes, we&rsquo;re running the Fargate Agent under the hood :)</p>
<p>Let&rsquo;s see what the namespace looks like from inside the network namespace (netns) of my awsvpc task. I&rsquo;ll use a nifty tool called <code>ip netns exec</code>, which allows me to launch commands inside a network namespace.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># ip netns exec a333f40b6ac74e92b1541fb0a5d76f9e-02ed2d974f29 ip link show</span>
</span></span><span style="display:flex;"><span>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span style="color:#ae81ff">65536</span> qdisc noqueue state UNKNOWN mode DEFAULT group default qlen <span style="color:#ae81ff">1000</span>
</span></span><span style="display:flex;"><span>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span style="display:flex;"><span>3: eth0@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span style="color:#ae81ff">1500</span> qdisc noqueue state UP mode DEFAULT group default 
</span></span><span style="display:flex;"><span>    link/ether 0a:58:a9:fe:ac:02 brd ff:ff:ff:ff:ff:ff link-netnsid <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>4: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span style="color:#ae81ff">9001</span> qdisc mq state UP mode DEFAULT group default qlen <span style="color:#ae81ff">1000</span>
</span></span><span style="display:flex;"><span>    link/ether 02:ed:2d:97:4f:29 brd ff:ff:ff:ff:ff:ff
</span></span><span style="display:flex;"><span>    altname enp0s6
</span></span><span style="display:flex;"><span>    altname ens6
</span></span></code></pre></div><p>Well, there it is. <code>eth1</code> is here! Notice that eth0 is <strong>not</strong> here. As far as the container namespace is concerned, there&rsquo;s only one ENI in this host.</p>
<p>Let&rsquo;s confirm by looking at the IP address assigned to <code>eth1</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># ip netns exec a333f40b6ac74e92b1541fb0a5d76f9e-02ed2d974f29 ip address show</span>
</span></span><span style="display:flex;"><span>1:...
</span></span><span style="display:flex;"><span>3:...
</span></span><span style="display:flex;"><span>4: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span style="color:#ae81ff">9001</span> qdisc mq state UP group default qlen <span style="color:#ae81ff">1000</span>
</span></span><span style="display:flex;"><span>    link/ether 02:ed:2d:97:4f:29 brd ff:ff:ff:ff:ff:ff
</span></span><span style="display:flex;"><span>    altname enp0s6
</span></span><span style="display:flex;"><span>    altname ens6
</span></span><span style="display:flex;"><span>    inet 10.194.20.168/24 scope global eth1
</span></span><span style="display:flex;"><span>       valid_lft forever preferred_lft forever
</span></span><span style="display:flex;"><span>    inet6 fe80::ed:2dff:fe97:4f29/64 scope link proto kernel_ll 
</span></span><span style="display:flex;"><span>       valid_lft forever preferred_lft forever
</span></span></code></pre></div><p>Yes, eth1 has <code>10.194.20.168</code> which matches what the AWS console tells me.</p>
<h2 id="the-complete-network-picture">The Complete Network Picture<a hidden class="anchor" aria-hidden="true" href="#the-complete-network-picture">#</a></h2>
<p>Okay, but what about the other stuff I see in the IP command output?</p>
<p>Yes, good question. This is not obvious, but there&rsquo;s one more thing: there&rsquo;s a bridge from the task namespace that connects it to the task metadata service (TMDS). The namespace is connected via a veth pair. The full namespace picture looks like this:</p>
<p><img loading="lazy" src="/img/v2-SingleBridge-Page-4.drawio-complte.png" alt="Complete Network Namespace Diagram"  />
</p>
<p>Now we see that <code>eth0@if5</code> is a veth (virtual ethernet) device connected to another veth in the primary interface that will route MAC frames to the fargate-bridge which acts as a virtual switch and will route MAC traffic to the task metadata server (TMDS) running on my primary namespace.</p>
<h2 id="what-else-goes-into-a-netns">What else goes into a netns?<a hidden class="anchor" aria-hidden="true" href="#what-else-goes-into-a-netns">#</a></h2>
<p>Besides the network interface we need to configure the namespace with everything it needs to work as an effectual copy of a Linux network stack, with its own routes, firewall rules and devices. In awsvpc tasks this means you get:</p>
<ul>
<li>A loopback interface</li>
<li>DNS configuration files</li>
<li>Routes in the iptables</li>
<li>A veth interface that connects to the primary netns</li>
</ul>
<h2 id="how-to-configure-network-namespaces-using-ip-commands">How to configure network namespaces using IP commands<a hidden class="anchor" aria-hidden="true" href="#how-to-configure-network-namespaces-using-ip-commands">#</a></h2>
<p>One way to configure network namespaces is to use the <a href="https://man7.org/linux/man-pages/man8/ip-netns.8.html">IP command</a> to create and configure the network namespace.</p>
<p>To configure a namespace like awsvpc, you need to create the netns and configure the ENI, you need to configure DNS and create a bridge from the netns to the task metadata server.</p>
<p>To create a netns use <code>ip netns add</code> command:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo ip netns add my_container_ns
</span></span></code></pre></div><p>This command creates a new, empty network namespace named my_container_ns. It will appear as a mount point under /var/run/netns. <a href="https://lwn.net/Articles/580893/">[1]</a></p>
<p>If you want to configure an ENI you&rsquo;d use <code>ip link</code> commands to create, setup, add IP address, set MTU, etc. For illustrative purposes I&rsquo;ve added some scripts created with generative AI.</p>
<p>This looks about right (use at your own risk, this is untested code).</p>
<p>To create a namespace with a bridge run something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e">#!/bin/bash
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e"># This script creates a network namespace, a veth pair, and a bridge between</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># the host and the network namespace.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>set -e
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- Configuration ---</span>
</span></span><span style="display:flex;"><span>NS_NAME<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;testns&#34;</span>         <span style="color:#75715e"># Name of the network namespace</span>
</span></span><span style="display:flex;"><span>VETH_HOST<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;veth-host&#34;</span>    <span style="color:#75715e"># veth interface in the root namespace</span>
</span></span><span style="display:flex;"><span>VETH_NS<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;veth-ns&#34;</span>        <span style="color:#75715e"># veth interface inside the namespace</span>
</span></span><span style="display:flex;"><span>BR_NAME<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;br0&#34;</span>            <span style="color:#75715e"># Name of the bridge</span>
</span></span><span style="display:flex;"><span>IP_HOST<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;10.200.1.1/24&#34;</span>  <span style="color:#75715e"># IP for host side of the bridge</span>
</span></span><span style="display:flex;"><span>IP_NS<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;10.200.1.2/24&#34;</span>    <span style="color:#75715e"># IP for namespace side</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- Cleanup any previous setup ---</span>
</span></span><span style="display:flex;"><span>cleanup<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;Cleaning up any previous setup...&#34;</span>
</span></span><span style="display:flex;"><span>    ip netns del <span style="color:#e6db74">&#34;</span>$NS_NAME<span style="color:#e6db74">&#34;</span> 2&gt;/dev/null <span style="color:#f92672">||</span> true
</span></span><span style="display:flex;"><span>    ip link del <span style="color:#e6db74">&#34;</span>$VETH_HOST<span style="color:#e6db74">&#34;</span> 2&gt;/dev/null <span style="color:#f92672">||</span> true
</span></span><span style="display:flex;"><span>    ip link del <span style="color:#e6db74">&#34;</span>$BR_NAME<span style="color:#e6db74">&#34;</span> 2&gt;/dev/null <span style="color:#f92672">||</span> true
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>cleanup
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- Create namespace ---</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Creating network namespace: </span>$NS_NAME<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>ip netns add <span style="color:#e6db74">&#34;</span>$NS_NAME<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- Create veth pair ---</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Creating veth pair: </span>$VETH_HOST<span style="color:#e6db74"> &lt;-&gt; </span>$VETH_NS<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>ip link add <span style="color:#e6db74">&#34;</span>$VETH_HOST<span style="color:#e6db74">&#34;</span> type veth peer name <span style="color:#e6db74">&#34;</span>$VETH_NS<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- Move one end into the namespace ---</span>
</span></span><span style="display:flex;"><span>ip link set <span style="color:#e6db74">&#34;</span>$VETH_NS<span style="color:#e6db74">&#34;</span> netns <span style="color:#e6db74">&#34;</span>$NS_NAME<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- Create and configure bridge ---</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Creating bridge: </span>$BR_NAME<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>ip link add name <span style="color:#e6db74">&#34;</span>$BR_NAME<span style="color:#e6db74">&#34;</span> type bridge
</span></span><span style="display:flex;"><span>ip addr add <span style="color:#e6db74">&#34;</span>$IP_HOST<span style="color:#e6db74">&#34;</span> dev <span style="color:#e6db74">&#34;</span>$BR_NAME<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>ip link set <span style="color:#e6db74">&#34;</span>$BR_NAME<span style="color:#e6db74">&#34;</span> up
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- Attach host veth to the bridge ---</span>
</span></span><span style="display:flex;"><span>ip link set <span style="color:#e6db74">&#34;</span>$VETH_HOST<span style="color:#e6db74">&#34;</span> master <span style="color:#e6db74">&#34;</span>$BR_NAME<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>ip link set <span style="color:#e6db74">&#34;</span>$VETH_HOST<span style="color:#e6db74">&#34;</span> up
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- Configure namespace side ---</span>
</span></span><span style="display:flex;"><span>ip netns exec <span style="color:#e6db74">&#34;</span>$NS_NAME<span style="color:#e6db74">&#34;</span> ip addr add <span style="color:#e6db74">&#34;</span>$IP_NS<span style="color:#e6db74">&#34;</span> dev <span style="color:#e6db74">&#34;</span>$VETH_NS<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>ip netns exec <span style="color:#e6db74">&#34;</span>$NS_NAME<span style="color:#e6db74">&#34;</span> ip link set <span style="color:#e6db74">&#34;</span>$VETH_NS<span style="color:#e6db74">&#34;</span> up
</span></span><span style="display:flex;"><span>ip netns exec <span style="color:#e6db74">&#34;</span>$NS_NAME<span style="color:#e6db74">&#34;</span> ip link set lo up
</span></span><span style="display:flex;"><span>ip netns exec <span style="color:#e6db74">&#34;</span>$NS_NAME<span style="color:#e6db74">&#34;</span> ip route add default via <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>IP_HOST%/*<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- Enable IP forwarding (optional) ---</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Enabling IP forwarding...&#34;</span>
</span></span><span style="display:flex;"><span>sysctl -w net.ipv4.ip_forward<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> &gt;/dev/null
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;â Setup complete!&#34;</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Namespace: </span>$NS_NAME<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Bridge:    </span>$BR_NAME<span style="color:#e6db74"> (</span>$IP_HOST<span style="color:#e6db74">)&#34;</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;veth pair: </span>$VETH_HOST<span style="color:#e6db74"> &lt;-&gt; </span>$VETH_NS<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>echo
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;To test connectivity:&#34;</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;  ip netns exec </span>$NS_NAME<span style="color:#e6db74"> ping -c 3 </span><span style="color:#e6db74">${</span>IP_HOST%/*<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;To enter the namespace shell:&#34;</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;  ip netns exec </span>$NS_NAME<span style="color:#e6db74"> bash&#34;</span>
</span></span></code></pre></div><p>To setup an ENI do something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e">#!/bin/bash
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e"># Configure an AWS Elastic Network Interface (ENI)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># using &#39;ip link set&#39;, &#39;ip address add&#39;, and &#39;ip link set up&#39;.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>set -euo pipefail
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- User configuration ---</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Change these to match your setup</span>
</span></span><span style="display:flex;"><span>ENI_IFACE<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;eth1&#34;</span>           <span style="color:#75715e"># The interface name of the ENI (check with `ip link`)</span>
</span></span><span style="display:flex;"><span>ENI_IP<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;10.0.2.50/24&#34;</span>      <span style="color:#75715e"># Private IP address for the ENI</span>
</span></span><span style="display:flex;"><span>ENI_GW<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;10.0.2.1&#34;</span>          <span style="color:#75715e"># Default gateway (in ENI&#39;s subnet)</span>
</span></span><span style="display:flex;"><span>ROUTE_TABLE<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;main&#34;</span>         <span style="color:#75715e"># Optional: routing table to use</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- Validate interface existence ---</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> ! ip link show <span style="color:#e6db74">&#34;</span>$ENI_IFACE<span style="color:#e6db74">&#34;</span> &amp;&gt;/dev/null; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;â Error: Interface </span>$ENI_IFACE<span style="color:#e6db74"> not found. Check &#39;ip link&#39; output.&#34;</span>
</span></span><span style="display:flex;"><span>    exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;ð§ Configuring ENI interface: </span>$ENI_IFACE<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- Bring interface down before configuring (optional safety) ---</span>
</span></span><span style="display:flex;"><span>ip link set <span style="color:#e6db74">&#34;</span>$ENI_IFACE<span style="color:#e6db74">&#34;</span> down
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- Assign IP address ---</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;â¡ï¸  Assigning IP address: </span>$ENI_IP<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>ip address flush dev <span style="color:#e6db74">&#34;</span>$ENI_IFACE<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>ip address add <span style="color:#e6db74">&#34;</span>$ENI_IP<span style="color:#e6db74">&#34;</span> dev <span style="color:#e6db74">&#34;</span>$ENI_IFACE<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- Bring interface up ---</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;â¬ï¸  Bringing interface up...&#34;</span>
</span></span><span style="display:flex;"><span>ip link set <span style="color:#e6db74">&#34;</span>$ENI_IFACE<span style="color:#e6db74">&#34;</span> up
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- Add default route (optional) ---</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;ð£ï¸  Setting default route via </span>$ENI_GW<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>ip route replace default via <span style="color:#e6db74">&#34;</span>$ENI_GW<span style="color:#e6db74">&#34;</span> dev <span style="color:#e6db74">&#34;</span>$ENI_IFACE<span style="color:#e6db74">&#34;</span> table <span style="color:#e6db74">&#34;</span>$ROUTE_TABLE<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>ip rule add from <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>ENI_IP%/*<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span> lookup <span style="color:#e6db74">&#34;</span>$ROUTE_TABLE<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">||</span> true
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;â ENI configuration complete!&#34;</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Interface: </span>$ENI_IFACE<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;IP:        </span>$ENI_IP<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Gateway:   </span>$ENI_GW<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>echo
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;To verify:&#34;</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;  ip addr show dev </span>$ENI_IFACE<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;  ip route show table </span>$ROUTE_TABLE<span style="color:#e6db74">&#34;</span>
</span></span></code></pre></div><h2 id="cni-plugins">CNI Plugins<a hidden class="anchor" aria-hidden="true" href="#cni-plugins">#</a></h2>
<p>Luckily, we don&rsquo;t have to use IP tools (I believe we used to before CNI plugins) since containerD relies on external plugins for network configuration. Unlike Docker users, containerD users have the freedom to customize the networking environment.</p>
<p>The CNI plugins and the netlib package in the ecs-agent shared library encapsulate the complexity of setting up network namespaces. The caller makes two method calls: one to build the namespace configuration and one to &ldquo;Start&rdquo; the namespace. The high level sequence of events from Start goes something like this:</p>
<p><img loading="lazy" src="/img/cni-seq.png" alt="CNI Workflow Diagram"  />
</p>
<ul>
<li><strong>Create Namespace</strong>
<ul>
<li>Configure DNS</li>
</ul>
</li>
<li><strong>Configure ENI</strong>
<ul>
<li><strong>Create Bridge</strong>
<ul>
<li>Get IP from IPAM</li>
<li>Setup routes with iptable entries</li>
</ul>
</li>
<li><strong>Configure Network Interface</strong>
<ul>
<li>Move to netns</li>
<li>Assign IPs</li>
<li>Configure iptables and routes</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The plugins mainly wrap IP commands from the netlink library. This Go library simplifies adding and removing interfaces. Netlink is the successor of ioctl, a set of system calls historically (although still supported in some distros) used to configure serial devices. Since network interfaces are usually ethernet (at least in EC2 instances) this is the way to programmatically setup the system. Our customers shouldn&rsquo;t have to care/worry since this is all done for them by the ECS dataplane.</p>
<h2 id="so-which-cnis-do-we-use">So which CNIs do we use?<a hidden class="anchor" aria-hidden="true" href="#so-which-cnis-do-we-use">#</a></h2>
<p>For setting up awsvpc namespaces without any special networking features (such as Service Connect, AppMesh, Multi-ENI) we use the following:</p>
<p><strong>ENI and Branch-ENI</strong></p>
<p>ECS Managed Instances and Fargate use two types of ENIs: x-ENIs (Regular ENIs in the code) and branch ENIs (ENIs that leverage trunking). They are in the ENI and branch-eni packages respectively. Under the hood the plugins call netlib to setup the links.</p>
<p>The <a href="https://github.com/aws/amazon-ecs-cni-plugins/tree/master/plugins/eni">ECS ENI plugin</a> configures a container&rsquo;s network namespace to use an Elastic Network Interface (ENI) directly. It moves an ENI from the host into the container&rsquo;s network namespace.</p>
<h2 id="key-components">Key Components<a hidden class="anchor" aria-hidden="true" href="#key-components">#</a></h2>
<h3 id="engine-interface">Engine Interface<a hidden class="anchor" aria-hidden="true" href="#engine-interface">#</a></h3>
<p>The core logic is in the <code>engine</code> package, which handles:</p>
<ul>
<li>Retrieving ENI metadata from EC2 instance metadata service</li>
<li>Finding the network device by MAC address</li>
<li>Setting up the container namespace with the ENI</li>
</ul>
<h3 id="main-flow">Main Flow<a hidden class="anchor" aria-hidden="true" href="#main-flow">#</a></h3>
<ol>
<li>
<p><strong>Plugin Entry</strong>: The main function uses CNI&rsquo;s <code>skel.PluginMain()</code> to handle ADD/DEL commands</p>
</li>
<li>
<p><strong>ADD Command Process</strong>:</p>
<ul>
<li>Parses configuration (ENI ID, MAC address, IP addresses)</li>
<li>Uses EC2 metadata service to find the ENI&rsquo;s network device name</li>
<li>Calls <code>SetupContainerNamespace()</code> to move the ENI into the container</li>
</ul>
</li>
<li>
<p><strong>Key Engine Operations</strong>:</p>
<ul>
<li><code>GetInterfaceDeviceName()</code>: Finds the host device name using the MAC address</li>
<li><code>GetIPV4GatewayNetmask()</code>: Retrieves gateway/netmask from EC2 metadata</li>
<li><code>GetIPV6Gateway()</code>: Gets IPv6 gateway from routing table</li>
<li><code>SetupContainerNamespace()</code>: Moves the ENI into container&rsquo;s network namespace</li>
</ul>
</li>
</ol>
<h2 id="configuration-parameters">Configuration Parameters<a hidden class="anchor" aria-hidden="true" href="#configuration-parameters">#</a></h2>
<p>The plugin accepts:</p>
<ul>
<li><code>eni</code>: ENI ID (required)</li>
<li><code>mac</code>: MAC address (required)</li>
<li><code>ipv4-address</code>: Primary IPv4 address (required)</li>
<li><code>ipv6-address</code>: IPv6 address (optional)</li>
<li><code>block-instance-metadata</code>: Block metadata access (optional)</li>
<li><code>stay-down</code>: Keep interface down (optional)</li>
</ul>
<h2 id="how-it-works">How It Works<a hidden class="anchor" aria-hidden="true" href="#how-it-works">#</a></h2>
<ol>
<li>The plugin receives an ENI that&rsquo;s already attached to the EC2 instance</li>
<li>It uses the MAC address to find the corresponding network interface on the host</li>
<li>It retrieves network configuration (gateway, netmask) from EC2 metadata service</li>
<li>It moves the entire ENI device into the container&rsquo;s network namespace</li>
<li>Optionally starts DHCP client for lease renewal</li>
</ol>
<p>This gives containers direct access to ENIs with their own IP addresses, enabling advanced networking features like security groups per container.</p>
<h1 id="ecs-bridge-and-ipam-plugins">ECS Bridge and IPAM Plugins<a hidden class="anchor" aria-hidden="true" href="#ecs-bridge-and-ipam-plugins">#</a></h1>
<h2 id="ecs-bridge-plugin"><a href="https://github.com/aws/amazon-ecs-cni-plugins/tree/master/plugins/ecs-bridge">ECS Bridge Plugin</a><a hidden class="anchor" aria-hidden="true" href="#ecs-bridge-plugin">#</a></h2>
<h3 id="overview">Overview<a hidden class="anchor" aria-hidden="true" href="#overview">#</a></h3>
<p>The ECS Bridge plugin creates a bridge network to connect containers to the ECS Agent&rsquo;s credentials endpoint. It creates a bridge device and veth pairs to enable communication between containers and the host.</p>
<h3 id="key-components-1">Key Components<a hidden class="anchor" aria-hidden="true" href="#key-components-1">#</a></h3>
<p><strong>Main Flow</strong>:</p>
<ol>
<li><strong>Bridge Creation</strong>: Creates or reuses a bridge device (e.g., <code>ecs-br0</code>)</li>
<li><strong>Veth Pair Creation</strong>: Creates a virtual ethernet pair - one end in container namespace, one on host</li>
<li><strong>IPAM Integration</strong>: Calls the ECS IPAM plugin to allocate IP addresses</li>
<li><strong>Interface Configuration</strong>: Configures both ends of the veth pair with IP addresses and routes</li>
</ol>
<p><strong>Key Operations</strong>:</p>
<ul>
<li><code>CreateBridge()</code>: Creates the bridge device with specified MTU</li>
<li><code>CreateVethPair()</code>: Creates veth pair connecting container to host</li>
<li><code>AttachHostVethInterfaceToBridge()</code>: Connects host veth to bridge</li>
<li><code>RunIPAMPluginAdd()</code>: Calls IPAM plugin for IP allocation</li>
<li><code>ConfigureContainerVethInterface()</code>: Sets up container&rsquo;s network interface</li>
<li><code>ConfigureBridge()</code>: Configures bridge with gateway IP</li>
</ul>
<h3 id="configuration-parameters-1">Configuration Parameters<a hidden class="anchor" aria-hidden="true" href="#configuration-parameters-1">#</a></h3>
<ul>
<li><code>bridge</code>: Bridge name (required)</li>
<li><code>ipam</code>: IPAM configuration (required)</li>
<li><code>mtu</code>: Maximum transmission unit (optional)</li>
</ul>
<h2 id="ecs-ipam-plugin"><a href="https://github.com/aws/amazon-ecs-cni-plugins/tree/master/plugins/ipam">ECS IPAM Plugin</a><a hidden class="anchor" aria-hidden="true" href="#ecs-ipam-plugin">#</a></h2>
<h3 id="overview-1">Overview<a hidden class="anchor" aria-hidden="true" href="#overview-1">#</a></h3>
<p>The ECS IPAM (IP Address Management) plugin allocates IP addresses from a specified subnet and manages IP address assignments using a BoltDB database for persistence.</p>
<h3 id="key-components-2">Key Components<a hidden class="anchor" aria-hidden="true" href="#key-components-2">#</a></h3>
<p><strong>IP Management</strong>:</p>
<ul>
<li>Uses BoltDB for persistent IP address tracking</li>
<li>Allocates IPs from a configured subnet (e.g., <code>169.254.172.0/22</code>)</li>
<li>Tracks last known IP to optimize allocation</li>
<li>Supports both automatic and manual IP assignment</li>
</ul>
<p><strong>Main Operations</strong>:</p>
<ul>
<li><code>Add()</code>: Allocates an IP address and returns network configuration</li>
<li><code>Del()</code>: Releases an IP address back to the pool</li>
<li><code>GetAvailableIP()</code>: Finds next available IP in subnet</li>
<li><code>Assign()</code>: Marks specific IP as used</li>
<li><code>Release()</code>: Frees an IP address</li>
</ul>
<h3 id="configuration-parameters-2">Configuration Parameters<a hidden class="anchor" aria-hidden="true" href="#configuration-parameters-2">#</a></h3>
<ul>
<li><code>ipv4-subnet</code>: CIDR block for allocations (required)</li>
<li><code>ipv4-address</code>: Specific IP to assign (optional)</li>
<li><code>ipv4-gateway</code>: Gateway IP (optional, defaults to .1)</li>
<li><code>ipv4-routes</code>: Routes to add to container (optional)</li>
<li><code>id</code>: Unique identifier for IP assignment (optional)</li>
</ul>
<h2 id="how-they-work-together">How They Work Together<a hidden class="anchor" aria-hidden="true" href="#how-they-work-together">#</a></h2>
<ol>
<li><strong>Bridge Plugin Invocation</strong>: ECS Agent calls bridge plugin with configuration</li>
<li><strong>Bridge Setup</strong>: Plugin creates bridge device and veth pair</li>
<li><strong>IPAM Call</strong>: Bridge plugin calls IPAM plugin to get IP allocation</li>
<li><strong>IP Assignment</strong>: IPAM plugin allocates IP from subnet and stores in database</li>
<li><strong>Interface Configuration</strong>: Bridge plugin configures container interface with allocated IP</li>
<li><strong>Route Setup</strong>: Adds routes for ECS credentials endpoint communication</li>
</ol>
<p>This enables containers to communicate with the ECS Agent&rsquo;s credentials endpoint at <code>169.254.170.2</code> while maintaining network isolation.</p>
<hr>
<p><em>This deep dive into ECS networking shows the sophisticated engineering that makes container isolation possible. Network namespaces provide the foundation for secure, isolated networking while CNI plugins abstract away the complexity for developers. Understanding these internals helps appreciate the elegant solutions that power modern container orchestration.</em></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/aws/">Aws</a></li>
      <li><a href="http://localhost:1313/tags/ecs/">Ecs</a></li>
      <li><a href="http://localhost:1313/tags/containers/">Containers</a></li>
      <li><a href="http://localhost:1313/tags/networking/">Networking</a></li>
      <li><a href="http://localhost:1313/tags/linux/">Linux</a></li>
      <li><a href="http://localhost:1313/tags/namespaces/">Namespaces</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2025 <a href="http://localhost:1313/">Yes Way Jose</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
