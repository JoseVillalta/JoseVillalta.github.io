<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Paper every day: Day Nine: An Analysis of Linux Scalability to Many Cores | Yes Way Jose</title><meta name=keywords content><meta name=description content="Link to Paper
From the abstract:
&ldquo;This paper analyzes the scalability of seven system applications running on Linux on a 48-core computer&mldr;using mostly standard parallel programming techniques -this paper introduces one new technique sloppy counters these bottlencek can be removed from the kernl or avoided by changing the application slightly&rdquo;
This paper has an excellent system level tutorial on scalability. They explain that you don&rsquo;t get linear increase in performance because in real life applications parallel tasks usually interact, an interaction forces serial execution."><meta name=author content="Jose Villalta"><link rel=canonical href=https://JoseVillalta.github.io/posts/day-nine-linux-scalability/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://JoseVillalta.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://JoseVillalta.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://JoseVillalta.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://JoseVillalta.github.io/apple-touch-icon.png><link rel=mask-icon href=https://JoseVillalta.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Paper every day: Day Nine: An Analysis of Linux Scalability to Many Cores"><meta property="og:description" content="Link to Paper
From the abstract:
&ldquo;This paper analyzes the scalability of seven system applications running on Linux on a 48-core computer&mldr;using mostly standard parallel programming techniques -this paper introduces one new technique sloppy counters these bottlencek can be removed from the kernl or avoided by changing the application slightly&rdquo;
This paper has an excellent system level tutorial on scalability. They explain that you don&rsquo;t get linear increase in performance because in real life applications parallel tasks usually interact, an interaction forces serial execution."><meta property="og:type" content="article"><meta property="og:url" content="https://JoseVillalta.github.io/posts/day-nine-linux-scalability/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-25T09:13:41-07:00"><meta property="article:modified_time" content="2022-07-25T09:13:41-07:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Paper every day: Day Nine: An Analysis of Linux Scalability to Many Cores"><meta name=twitter:description content="Link to Paper
From the abstract:
&ldquo;This paper analyzes the scalability of seven system applications running on Linux on a 48-core computer&mldr;using mostly standard parallel programming techniques -this paper introduces one new technique sloppy counters these bottlencek can be removed from the kernl or avoided by changing the application slightly&rdquo;
This paper has an excellent system level tutorial on scalability. They explain that you don&rsquo;t get linear increase in performance because in real life applications parallel tasks usually interact, an interaction forces serial execution."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://JoseVillalta.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Paper every day: Day Nine: An Analysis of Linux Scalability to Many Cores","item":"https://JoseVillalta.github.io/posts/day-nine-linux-scalability/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Paper every day: Day Nine: An Analysis of Linux Scalability to Many Cores","name":"Paper every day: Day Nine: An Analysis of Linux Scalability to Many Cores","description":"Link to Paper\nFrom the abstract:\n\u0026ldquo;This paper analyzes the scalability of seven system applications running on Linux on a 48-core computer\u0026hellip;using mostly standard parallel programming techniques -this paper introduces one new technique sloppy counters these bottlencek can be removed from the kernl or avoided by changing the application slightly\u0026rdquo;\nThis paper has an excellent system level tutorial on scalability. They explain that you don\u0026rsquo;t get linear increase in performance because in real life applications parallel tasks usually interact, an interaction forces serial execution.","keywords":[],"articleBody":"Link to Paper\nFrom the abstract:\n“This paper analyzes the scalability of seven system applications running on Linux on a 48-core computer…using mostly standard parallel programming techniques -this paper introduces one new technique sloppy counters these bottlencek can be removed from the kernl or avoided by changing the application slightly”\nThis paper has an excellent system level tutorial on scalability. They explain that you don’t get linear increase in performance because in real life applications parallel tasks usually interact, an interaction forces serial execution. Then they list the common causes with common solutions. This paper is throughly written and researched. Writing truly parallel code is difficult and even then applications still compete for some shared resouce, be it a local cache, network access or disk I/O.\nThe authors introduce the concept of sloppy counters which avoid the bottlenect that occurs when Linux uses shared reference counters for garbage collection and managing various resources. The authors report bottlenecks from reference counts on directory entry objects (dentrys), mounted file system objects (vfsmounts), network rounting table entries and counters traking the amount of memory allocated by each network protocol.\nFigure 1 in the paper provide a summary of linux scability problems that it’s worth using as a reference\nParallel accept dentry reference counting vfsmount reference counting IP packet destination reference counting Acquiring dentry spin locks mount point table spin lock Adding files to the open list Allocating DMA buffers False sharing in net_device and device False sharing in page inode lists Dcache lists Per-inode mutex Super-page fine grained locking Zeroing super-pages ","wordCount":"258","inLanguage":"en","datePublished":"2022-07-25T09:13:41-07:00","dateModified":"2022-07-25T09:13:41-07:00","author":{"@type":"Person","name":"Jose Villalta"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://JoseVillalta.github.io/posts/day-nine-linux-scalability/"},"publisher":{"@type":"Organization","name":"Yes Way Jose","logo":{"@type":"ImageObject","url":"https://JoseVillalta.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://JoseVillalta.github.io accesskey=h title="Yes Way Jose (Alt + H)">Yes Way Jose</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://JoseVillalta.github.io/experience/ title=CV><span>CV</span></a></li><li><a href=https://JoseVillalta.github.io/about/ title="About Me"><span>About Me</span></a></li><li><a href=http://joseavillalta.blogspot.com/ title="Old Blog"><span>Old Blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Paper every day: Day Nine: An Analysis of Linux Scalability to Many Cores</h1><div class=post-meta><span title='2022-07-25 09:13:41 -0700 -0700'>July 25, 2022</span>&nbsp;·&nbsp;Jose Villalta</div></header><div class=post-content><p><a href=https://pdos.csail.mit.edu/papers/linux:osdi10.pdf>Link to Paper</a></p><p>From the abstract:</p><p>&ldquo;This paper analyzes the scalability of seven system applications running on Linux on a 48-core computer&mldr;using mostly standard parallel programming techniques -this paper introduces one new technique <strong>sloppy counters</strong> these bottlencek can be removed from the kernl or avoided by changing the application slightly&rdquo;</p><p>This paper has an excellent system level tutorial on scalability. They explain that you don&rsquo;t get linear increase in performance because in real life applications parallel tasks usually interact, an interaction forces serial execution. Then they list the common causes with common solutions. This paper is throughly written and researched. Writing truly parallel code is difficult and even then applications still compete for some shared resouce, be it a local cache, network access or disk I/O.</p><p>The authors introduce the concept of <strong>sloppy counters</strong> which avoid the bottlenect that occurs when Linux uses shared reference counters for garbage collection and managing various resources. The authors report bottlenecks from reference counts on directory entry objects (dentrys), mounted file system objects (vfsmounts), network rounting table entries and counters traking the amount of memory allocated by each network protocol.</p><p>Figure 1 in the paper provide a summary of linux scability problems that it&rsquo;s worth using as a reference</p><ul><li>Parallel accept</li><li>dentry reference counting</li><li>vfsmount reference counting</li><li>IP packet destination reference counting</li><li>Acquiring dentry spin locks</li><li>mount point table spin lock</li><li>Adding files to the open list</li><li>Allocating DMA buffers</li><li>False sharing in net_device and device</li><li>False sharing in page</li><li>inode lists</li><li>Dcache lists</li><li>Per-inode mutex</li><li>Super-page fine grained locking</li><li>Zeroing super-pages</li></ul></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://JoseVillalta.github.io>Yes Way Jose</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>