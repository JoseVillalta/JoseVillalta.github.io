<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Posts on Yes Way Jose</title><link>https://JoseVillalta.github.io/posts/</link><description>Recent content in Posts on Yes Way Jose</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 01 Mar 2025 16:13:55 -0800</lastBuildDate><atom:link href="https://JoseVillalta.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>How do you architech change? The answer is simple, but not always easy</title><link>https://JoseVillalta.github.io/posts/useful-strategies-for-growing/</link><pubDate>Sat, 01 Mar 2025 16:13:55 -0800</pubDate><guid>https://JoseVillalta.github.io/posts/useful-strategies-for-growing/</guid><description>&lt;p>This week I had an Eureka moment at work. You see, there are many things I see at work that I would like to improve. Technical debt in our codebase. Inefficient processes. Communication silos across teams. The list of things one can improve never ends, this is true in all software shops. System complixity grows as new functionality gets added, inefficiencies optimized, bugs fixed. Secuirty hardened, etc.&lt;/p>
&lt;p>How do you increase the quality of your system without interrupting the flow? Well, obviously, you break it up, one tiny thing at time. That&amp;rsquo;s how. Yeah it&amp;rsquo;s obvious but (this is embarrasing to admit) I get the urge to make BIG changes, I&amp;rsquo;d like to rewrite whole chuncks of the codebase, I&amp;rsquo;d like to build a brand new release pipeline, and we might do that someday, but not today. When you have a team that&amp;rsquo;s busy doing the work, tidying up gets deprioritized. After all, that bug in prod needs to get fixed yesterday, that new feature needs to ship on time. Oh, by the way, the developer that was working on that thing your system depends on quit last week.&lt;/p></description></item><item><title>Learning Go</title><link>https://JoseVillalta.github.io/posts/learning-go/</link><pubDate>Tue, 27 Aug 2024 08:32:11 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/learning-go/</guid><description>&lt;p>I have been an official Go programmer for three years now. Unlike many people in my team, I remember the day Google announced go. I don&amp;rsquo;t remember if it was in Hacker News or /programming reddit, but I do remember watching the go math package compiling in less than a second, at the time, I was writing C++ for an embedded system. Building the whole model as we used to say took 45 minutes, this compiled our C/C++ project into a .out file for an ARM9 and a C55 DSP. When I saw how quickly Go built I was like, wow. To be fair, our build was for a Real Time OS so it didn&amp;rsquo;t even include the C++ standard library. Most of the time, if I remember right, was spent linking everything. THe linker was getting it&amp;rsquo;s poor butt kicked. Anyyway, I looked at Rob Pike (?) on YouTube and I was like,&lt;/p></description></item><item><title>Awesome Falsehoods Programmers Believe</title><link>https://JoseVillalta.github.io/posts/awesome-falsehoods/</link><pubDate>Wed, 08 Nov 2023 07:57:58 -0800</pubDate><guid>https://JoseVillalta.github.io/posts/awesome-falsehoods/</guid><description>&lt;h3 id="a-curated-list-of-falsehoods-programmers-believe-in">A curated list of falsehoods programmers believe in.&lt;/h3>
&lt;p>The Code we write is a representation of the things we believe are true about the world. Every one has just one name, right? Well, most of the time, yes. All of the time? No. If you write an app for yourself, or your small business most of these assumptions are fine. If you write code for millions of users, you are going to find exceptions. Some of them surprise me. Dealing with Time sucks, dealing with addresses, names, supporting multiple languages it&amp;rsquo;s really hard to get it right 100% of the time.&lt;/p></description></item><item><title>Book Summary: Thinking in Systems by Donella Meadows</title><link>https://JoseVillalta.github.io/posts/systems-book-notes/</link><pubDate>Sat, 04 Nov 2023 16:18:25 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/systems-book-notes/</guid><description>&lt;h2 id="book-summary-thinking-in-systems">Book Summary: Thinking in Systems&lt;/h2>
&lt;p>Let&amp;rsquo;s say you want to build the perfect self-driving vehicle. This thing you want to make is composed of many parts. There&amp;rsquo;s the car itself made up of many subparts (engine, tires, transmission, etc) as well as the AI tech. Realistically you will need a bunch of speciallized embedded systems as well as a central computer to orchestrate everything. There&amp;rsquo;s sensors, actuators, orchestrators, etc.
In short, how does one person know if a design is good? How do you know how fast the visual recognition needs to be to handle controlling a car going 60 mph?&lt;/p></description></item><item><title>The top 3 podcasts for Software Developers</title><link>https://JoseVillalta.github.io/posts/best-podcasts/</link><pubDate>Tue, 31 Oct 2023 09:05:57 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/best-podcasts/</guid><description>&lt;h3 id="the-top-3-podcasts-for-software-developers">The Top 3 Podcasts for Software Developers&lt;/h3>
&lt;h4 id="go-time-by-changelog">Go Time by Changelog&lt;/h4>
&lt;p>&lt;a href="https://changelog.com/gotime">link&lt;/a>&lt;/p>
&lt;p>This is the podcast to keep up-to-date with all things Go. The jokes are nerdy and the hosts are sometimes not as funny as they think they are, but the content is great and they have a wide set of guests in the show that make it a must for all people who write go for a living&lt;/p></description></item><item><title>Article Review: Lessons Learned from Twenty Years of Site Reliability Engineering</title><link>https://JoseVillalta.github.io/posts/twenty-years-of-sre-lessons-learned/</link><pubDate>Tue, 31 Oct 2023 08:29:26 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/twenty-years-of-sre-lessons-learned/</guid><description>&lt;h3 id="article-lessons-learned-from-twenty-years-of-site-reliability-engineering">Article: Lessons Learned from Twenty Years of Site Reliability Engineering&lt;/h3>
&lt;p>&lt;a href="https://sre.google/resources/practices-and-processes/twenty-years-of-sre-lessons-learned/">Link to article&lt;/a>&lt;/p>
&lt;p>The site realibility team at Google put together a summary of the lessons they have learned over the years. I am glad they decided to share. The best way to learn is by trial and error. Want your product or service to be better? Launch it, monitor it, and learn from the mistakes. It nice to learn from others, but there is no substitue to first hand experience. This is the list they came up with:&lt;/p></description></item><item><title>Staff Engineer Path</title><link>https://JoseVillalta.github.io/posts/staff-engineer-path/</link><pubDate>Mon, 24 Jul 2023 09:05:00 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/staff-engineer-path/</guid><description>&lt;h3 id="book-review-the-staff-engineers-path-by-tanya-reilly">Book Review: The Staff Engineer&amp;rsquo;s Path by Tanya Reilly&lt;/h3>
&lt;p>Tanya Reilly gives a guide for individual contributor software engineers who wish to grow their career but do not want to become managers. It gives insights about what a staff engineer does, and what you need to do to perform at that level. This is a technology-agnostic book. It gives the reader a high level view of the functional areas that matter.&lt;/p></description></item><item><title>Coroutines for Go</title><link>https://JoseVillalta.github.io/posts/coroutines-for-go/</link><pubDate>Tue, 18 Jul 2023 06:51:45 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/coroutines-for-go/</guid><description>&lt;h3 id="go">Go&lt;/h3>
&lt;p>Russ Cox put out an &lt;a href="https://research.swtch.com/coro">article&lt;/a> yesteday about adding the abilities to run coroutines in go. Today I learned the difference
between a &lt;a href="https://go.dev/tour/concurrency/1">goroutine&lt;/a> and a &lt;a href="https://en.wikipedia.org/wiki/Coroutine">coroutine&lt;/a>. Coroutine is a concurrency pattern in which only one runs at a time. Say we have coroutine A and B. B waits while A runs then A yields to B and A waits while B runs. It turns out this is useful in a few scenarios.&lt;/p></description></item><item><title>Learning File Systems</title><link>https://JoseVillalta.github.io/posts/learning-file-systems/</link><pubDate>Sat, 15 Jul 2023 21:21:31 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/learning-file-systems/</guid><description>&lt;p>Lately I have been learning about File Systems from the book &amp;ldquo;Operating Systems. Three Easy Pieces&amp;rdquo; by Remzi Arpaci-Dusseau.&lt;/p>
&lt;p>I used to think that I knew how file systems worked because the interface open, read and write is so straight forward, what else could there be to it? But then at work some weird issues come up where some weird behaviour happens, like, du says the disk has space but df says the disk is full, what could make that happen? Or when an issue mounting a volume occurs and you realize that you don&amp;rsquo;t know the difference between mounting a block device versus mounting a file system. Are they both the same thing? I need to have a mental model of what the system is doing in order to debug it. Knowing the data structures in the file system and having an idea of what happens when you open a file, how does the operating system find the file? how does it traverse the file tree? What is in memory versus disk?
I must confess I am still in the dark when it comes to container images and union file systems. I understand how a container is made up of many layers over imposed on top of each other. An image is essentially a tar file of different file systems on top of each other. But, how is it implemented? how do you, can you just put a whole other /proc and other system files on top of a kernel?
So anyway, that&amp;rsquo;s what I have been up to.&lt;/p></description></item><item><title>My Tsundoku Pile</title><link>https://JoseVillalta.github.io/posts/my-tsundoku-pile/</link><pubDate>Sun, 22 Jan 2023 20:02:32 -0800</pubDate><guid>https://JoseVillalta.github.io/posts/my-tsundoku-pile/</guid><description>&lt;figure>
&lt;img loading="lazy" src="https://JoseVillalta.github.io/img/pile.jpg"/>
&lt;/figure>
&lt;p>I&amp;rsquo;m trying to get through all my technical books that I&amp;rsquo;ve adquired, and never gotten around to.
Not going to lie, the Knuth books are intimidating. They are actually not that bad to get through, but they are books that I pick up, read a few pages on a specfic project, try to do a problem or two, and that&amp;rsquo;s it.&lt;/p>
&lt;p>The other books are less intimidating, more doable, I&amp;rsquo;m pretty sure al but one of these books were lying around the Amazon campus just sitting on shelves.&lt;/p></description></item><item><title>Paper every Day. Day ten: The Unix Timesharing System by Dennis Ritchie and Ken Thompson</title><link>https://JoseVillalta.github.io/posts/day-ten-unix-timesharing/</link><pubDate>Sun, 31 Jul 2022 10:40:30 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/day-ten-unix-timesharing/</guid><description>&lt;p>&lt;a href="https://dsf.berkeley.edu/cs262/unix.pdf">Link to Paper&lt;/a>&lt;/p>
&lt;p>This paper, published in July 1974 is remarkable because the design decisions that were made back then by these guys working at Bell Labs on an operating system for the &lt;a href="https://en.wikipedia.org/wiki/PDP-11">PDP-11 &lt;/a> are still relevant.&lt;/p>
&lt;p>I am still struggling to create a mental model of the unix file system, the fact that it looks like a single tree with the root at the top while simultaneously you can have multiple devices &lt;a href="https://en.wikipedia.org/wiki/Mount_(Unix)">mounted&lt;/a> dates back to these guys at Bell Labs.&lt;/p></description></item><item><title>Paper every day: Day Nine: An Analysis of Linux Scalability to Many Cores</title><link>https://JoseVillalta.github.io/posts/day-nine-linux-scalability/</link><pubDate>Mon, 25 Jul 2022 09:13:41 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/day-nine-linux-scalability/</guid><description>&lt;p>&lt;a href="https://pdos.csail.mit.edu/papers/linux:osdi10.pdf">Link to Paper&lt;/a>&lt;/p>
&lt;p>From the abstract:&lt;/p>
&lt;p>&amp;ldquo;This paper analyzes the scalability of seven system applications running on Linux on a 48-core computer&amp;hellip;using mostly standard parallel programming techniques -this paper introduces one new technique &lt;strong>sloppy counters&lt;/strong> these bottlencek can be removed from the kernl or avoided by changing the application slightly&amp;rdquo;&lt;/p>
&lt;p>This paper has an excellent system level tutorial on scalability. They explain that you don&amp;rsquo;t get linear increase in performance because in real life applications parallel tasks usually interact, an interaction forces serial execution. Then they list the common causes with common solutions. This paper is throughly written and researched. Writing truly parallel code is difficult and even then applications still compete for some shared resouce, be it a local cache, network access or disk I/O.&lt;/p></description></item><item><title>Lets Go</title><link>https://JoseVillalta.github.io/posts/lets-go/</link><pubDate>Sun, 24 Jul 2022 21:42:07 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/lets-go/</guid><description>&lt;h3 id="go">Go&lt;/h3>
&lt;p>I have been writing go since a little after last year. I actually remember hearing about go when it first came out, back then I honestly never thought I&amp;rsquo;d be getting paid to work in it.&lt;/p>
&lt;p>Even though I&amp;rsquo;ve been writing code in go for a while, I don&amp;rsquo;t think I know the language in enough depth to consider myself a go expert. I want to change that. So I am going to start writing about go here as a way to &amp;ldquo;learn in public&amp;rdquo;
Expect posts on the following topics:&lt;/p></description></item><item><title>Paper every day. Day Eight. Omega: flexible scalable scheduler for large compute clusters</title><link>https://JoseVillalta.github.io/posts/day-eight-omega/</link><pubDate>Sun, 24 Jul 2022 21:30:27 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/day-eight-omega/</guid><description>&lt;h3 id="omega">Omega&lt;/h3>
&lt;p>&lt;a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/41684.pdf">Link to paper&lt;/a>&lt;/p>
&lt;p>Omega was the second cluster manager system built by Google. It is Borg&amp;rsquo;s sucessor and it was designed as a happy medium between Borg&amp;rsquo;s centralized scheduler architecture and Mesos&amp;rsquo;s two-level approach where the placement is delegated to the running framework. Omega shares the state of the cluster among leaders and uses optimistic concurrency control (detect when different cluster schedulers are competing for the same resource)&lt;/p>
&lt;p>The premise of the whole paper is that a centralized scheduler does not scale well, so there must be a better way to handle scheduling different types of workloads in a fast and conrrect manner. The two main types of workloads, services and batches have different requriements and present their unique challenges. The paper explains the type of simulations the engineer at Google used to determine that conflicts among different scheduler is not that common and that Omega manages to fit more tasks in the clusters than Mesos.&lt;/p></description></item><item><title>Paper every day. Day Seven: Large-scale cluster management at Google with Borg</title><link>https://JoseVillalta.github.io/posts/day-seven-borg/</link><pubDate>Sat, 23 Jul 2022 18:56:09 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/day-seven-borg/</guid><description>&lt;h3 id="borg">Borg&lt;/h3>
&lt;p>&lt;a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/43438.pdf">Link to Paper&lt;/a>&lt;/p>
&lt;p>Borg is the cluster management system that runs hundreds of thousands of jobs at Google, it is the original system, it&amp;rsquo;s sucessor Omega was written as a reaction to the lessons learned from it. Kubernetes is the third system written with the lessons from those two. This paper helped me understand a few things about my own system since we have our own cluster managenet and scheduler system that work a little different but in general do the same job.&lt;/p></description></item><item><title>Paper every day. Day Six: Hints for Computer Design</title><link>https://JoseVillalta.github.io/posts/day-six-hints-computer-design/</link><pubDate>Fri, 22 Jul 2022 08:13:55 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/day-six-hints-computer-design/</guid><description>&lt;p>&lt;a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/acrobat-17.pdf">Link to Paper&lt;/a>&lt;/p>
&lt;p>This paper was published originally in 1983 by the legendary folks from the Xerox Palo Alto Research Center.
The hints and tips should sound familiar but it&amp;rsquo;s interesting to notice the &lt;strong>layer&lt;/strong> the author is talking about, these guys were designing at very low level.
The fact that the same rules apply now it&amp;rsquo;s remarkable. It turns out breaking up a system into the right abstraction with a good interface it&amp;rsquo;s rather hard.&lt;/p></description></item><item><title>Paper every day. Day Five: On Designing and Deploying Internet Scale Services</title><link>https://JoseVillalta.github.io/posts/day-five-design-internet-scale/</link><pubDate>Thu, 21 Jul 2022 07:07:19 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/day-five-design-internet-scale/</guid><description>&lt;p>&lt;a href="https://s3.amazonaws.com/systemsandpapers/papers/hamilton.pdf">Link to Paper&lt;/a>&lt;/p>
&lt;p>This paper is a list of recommendations for running a large-scale system that aims to keep quality high and costs low. The author comes from the Windows Live Services Platform but this might as well be read as an Amazon internal guide since I didn&amp;rsquo;t see a thing in this list that we don&amp;rsquo;t do (or aim to do) in AWS. EDIT: Of course all these things sound familiar! The author is &lt;a href="https://perspectives.mvdirona.com/">James Hamilton!&lt;/a> He&amp;rsquo;s a VP and distinguished engineer here at AWS, I know him from leading the weekly AWS Ops Review meeting.&lt;/p></description></item><item><title>Paper every day. Day Four: Harvest, Yield, and Scalable Tolerant Systems</title><link>https://JoseVillalta.github.io/posts/day-four-harvest-yield/</link><pubDate>Wed, 20 Jul 2022 06:28:24 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/day-four-harvest-yield/</guid><description>&lt;p>&lt;a href="https://s3.amazonaws.com/systemsandpapers/papers/FOX_Brewer_99-Harvest_Yield_and_Scalable_Tolerant_Systems.pdf">Link to paper&lt;/a>&lt;/p>
&lt;p>Today&amp;rsquo;s paper comes thanks to &lt;a href="https://lethain.com/">Will Larson&lt;/a> this is a recommended paper in his book &lt;a href="https://www.amazon.com/dp/B07QYCHJ7V/">Elegant Puzzle&lt;/a>&lt;/p>
&lt;p>This paper builds on the concepts from the the &lt;a href="https://en.wikipedia.org/wiki/CAP_theorem">CAP Theorem&lt;/a> which essentially says that when it comes to distributed systems you can only have 2 out of these 3 qualities:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Consistency&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Avalaibility&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Partition Tolerance&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Then it introduces two concepts &lt;strong>harvest&lt;/strong> and &lt;strong>yield&lt;/strong> which is interesting because it&amp;rsquo;s not something you usually hear in distributed systems (this is a paper from the &amp;rsquo;90s) and yet I think it&amp;rsquo;s import to know and to think in these terms.&lt;/p></description></item><item><title>Paper every day. Day Three: Container Design Patterns</title><link>https://JoseVillalta.github.io/posts/day-three-container-design-patterns/</link><pubDate>Tue, 19 Jul 2022 07:23:34 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/day-three-container-design-patterns/</guid><description>&lt;h3 id="day-three-design-patterns-for-container-based-distributed-systems">Day three: Design patterns for container-based distributed systems&lt;/h3>
&lt;p>&lt;a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/45406.pdf">Link to paper&lt;/a>&lt;/p>
&lt;p>Containers provide the ability to package, deploy and reuse applications using a natural isolation boundary. Developers can expose application-specific functionality as interfaces as well as more generic hooks for many systems like metrics, health, etc.&lt;/p>
&lt;p>In this paper the authors present the readers with two types of container design patterns: Patterns for container in the same machine (Single node) and patterns where the containers are spread out in different machines (multi node)&lt;/p></description></item><item><title>Paper every day. Day Two: Kubernetes</title><link>https://JoseVillalta.github.io/posts/day-two-k8s/</link><pubDate>Mon, 18 Jul 2022 06:33:49 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/day-two-k8s/</guid><description>&lt;!-- raw HTML omitted -->
&lt;p>Welcome to day 2 of my paper-every-day journey. Today we&amp;rsquo;re going to cover &lt;a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/44843.pdf">Borg, Omega and Kubernetes&lt;/a> This paper goes over how Kubernetes, the de-facto, open-source orchestrator of containers was developed using the lessons learned from building Borg and Omega, Google&amp;rsquo;s internal job orchestrator.&lt;/p>
&lt;p>Kubernetes is a container orchestration system that aims to make developing and deploying complex distributed systems easier.
The Borg and Omega papers are excellent papers on their own right, but this explanation original published in ACM Queue is very insightful. These are the lessons I gathered:&lt;/p></description></item><item><title>Goal: A Paper Every Day. Day One: Mesos Paper</title><link>https://JoseVillalta.github.io/posts/day-one-paper/</link><pubDate>Sun, 17 Jul 2022 13:04:01 -0700</pubDate><guid>https://JoseVillalta.github.io/posts/day-one-paper/</guid><description>&lt;p>I&amp;rsquo;ve decided to read a research paper each day. I am doing this in order to get better at my craft.
I want to be better at designing software and it has been shown in research that the people who are really good at what they do
are those that do &amp;ldquo;delibarate practice&amp;rdquo; I am most definitely NOT the best software system designer out there, but talent is overated and I
intend to improve my knowledge one day at time. You are welcome to follow along.&lt;/p></description></item><item><title>New blog!</title><link>https://JoseVillalta.github.io/posts/sample/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://JoseVillalta.github.io/posts/sample/</guid><description>&lt;p>Started a new page to write about tech stuff. Work in Progress&lt;/p></description></item></channel></rss>