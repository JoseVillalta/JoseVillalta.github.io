<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Paper every day. Day Three: Container Design Patterns | Yes Way Jose</title>
<meta name=keywords content><meta name=description content="Day three: Design patterns for container-based distributed systems
Link to paper
Containers provide the ability to package, deploy and reuse applications using a natural isolation boundary. Developers can expose application-specific functionality as interfaces as well as more generic hooks for many systems like metrics, health, etc.
In this paper the authors present the readers with two types of container design patterns: Patterns for container in the same machine (Single node) and patterns where the containers are spread out in different machines (multi node)"><meta name=author content="Jose Villalta"><link rel=canonical href=https://JoseVillalta.github.io/posts/day-three-container-design-patterns/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2eadbb982468c11a433a3e291f01326f2ba43f065e256bf792dbd79640a92316.js integrity="sha256-Lq27mCRowRpDOj4pHwEybyukPwZeJWv3ktvXlkCpIxY=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://JoseVillalta.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://JoseVillalta.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://JoseVillalta.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://JoseVillalta.github.io/apple-touch-icon.png><link rel=mask-icon href=https://JoseVillalta.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://JoseVillalta.github.io/posts/day-three-container-design-patterns/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Paper every day. Day Three: Container Design Patterns"><meta property="og:description" content="Day three: Design patterns for container-based distributed systems
Link to paper
Containers provide the ability to package, deploy and reuse applications using a natural isolation boundary. Developers can expose application-specific functionality as interfaces as well as more generic hooks for many systems like metrics, health, etc.
In this paper the authors present the readers with two types of container design patterns: Patterns for container in the same machine (Single node) and patterns where the containers are spread out in different machines (multi node)"><meta property="og:type" content="article"><meta property="og:url" content="https://JoseVillalta.github.io/posts/day-three-container-design-patterns/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-19T07:23:34-07:00"><meta property="article:modified_time" content="2022-07-19T07:23:34-07:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Paper every day. Day Three: Container Design Patterns"><meta name=twitter:description content="Day three: Design patterns for container-based distributed systems
Link to paper
Containers provide the ability to package, deploy and reuse applications using a natural isolation boundary. Developers can expose application-specific functionality as interfaces as well as more generic hooks for many systems like metrics, health, etc.
In this paper the authors present the readers with two types of container design patterns: Patterns for container in the same machine (Single node) and patterns where the containers are spread out in different machines (multi node)"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://JoseVillalta.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Paper every day. Day Three: Container Design Patterns","item":"https://JoseVillalta.github.io/posts/day-three-container-design-patterns/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Paper every day. Day Three: Container Design Patterns","name":"Paper every day. Day Three: Container Design Patterns","description":"Day three: Design patterns for container-based distributed systems Link to paper\nContainers provide the ability to package, deploy and reuse applications using a natural isolation boundary. Developers can expose application-specific functionality as interfaces as well as more generic hooks for many systems like metrics, health, etc.\nIn this paper the authors present the readers with two types of container design patterns: Patterns for container in the same machine (Single node) and patterns where the containers are spread out in different machines (multi node)\n","keywords":[],"articleBody":"Day three: Design patterns for container-based distributed systems Link to paper\nContainers provide the ability to package, deploy and reuse applications using a natural isolation boundary. Developers can expose application-specific functionality as interfaces as well as more generic hooks for many systems like metrics, health, etc.\nIn this paper the authors present the readers with two types of container design patterns: Patterns for container in the same machine (Single node) and patterns where the containers are spread out in different machines (multi node)\nSingle Node Patterns Sidecar Pattern\nSidecar patterns extend and enhance the main container. A webserver container and logger running alongside in the same machine is a common example. Developers could package the whole application as a single container but separating them brings advantages:\nA container is a single unit of allocation for thinking about resource consumptions A container is a unit of packaging for dependency management. You can implement your server and logger in different languages or usind different versions of the same libraries A container is a unit of reuse. You can write your logger once and reuse it in other applications. A container provides a single failure boundary making it possible to degrade gracefully A container is a unit of deployment, which allows each piece of functionality to be upgraded and rolled back idependently Ambassador Pattern\nAmbassador containers proxy communication to and from a main containers. For example a developer could be writing an application that send data to different services located in different network namespaces the ambassador provides a simple interface to the container to hide away the details of routing request to the appropriate destination.\nAdapter Pattern\nAdapters present the outside world with a simplified, consistent view of an application for example, exposing metrics to the outside world. It’s the opposite of the ambassador pattern in the sense that it simplifies the view of the container to the system.\nMulti Node Patterns Leader election pattern\nLeader election is a common functionality when replication is used.\nWork queue pattern\nWith containers it should be straight forward to build systems that can act as a generic work queue.\nScatter/Gather\nMap reduce is an example of this. Clients configure a job, you have one container in charge of sending out work to be done in parallel and the mapper gathers all the results and reduces it down to a single results. This pattern can be applied to many big data applications.\nPersonally, I have seen the sidecar, ambassador and adapter pattern a lot but I think the multi-node patterns are examples of things that get implemented once and then become part of the infrastructure, there are multiple systems that implement work queues, leader election and scatter gather, so there is no need to re-implement it when somebody probably has done a better job.\n","wordCount":"467","inLanguage":"en","datePublished":"2022-07-19T07:23:34-07:00","dateModified":"2022-07-19T07:23:34-07:00","author":{"@type":"Person","name":"Jose Villalta"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://JoseVillalta.github.io/posts/day-three-container-design-patterns/"},"publisher":{"@type":"Organization","name":"Yes Way Jose","logo":{"@type":"ImageObject","url":"https://JoseVillalta.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://JoseVillalta.github.io/ accesskey=h title="Yes Way Jose (Alt + H)">Yes Way Jose</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://JoseVillalta.github.io/experience/ title=CV><span>CV</span></a></li><li><a href=https://JoseVillalta.github.io/about/ title="About Me"><span>About Me</span></a></li><li><a href=http://joseavillalta.blogspot.com/ title="Personal Blog"><span>Personal Blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Paper every day. Day Three: Container Design Patterns</h1><div class=post-meta>&lt;span title='2022-07-19 07:23:34 -0700 -0700'>July 19, 2022&lt;/span>&amp;nbsp;·&amp;nbsp;Jose Villalta</div></header><div class=post-content><h3 id=day-three-design-patterns-for-container-based-distributed-systems>Day three: Design patterns for container-based distributed systems<a hidden class=anchor aria-hidden=true href=#day-three-design-patterns-for-container-based-distributed-systems>#</a></h3><p><a href=https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/45406.pdf>Link to paper</a></p><p>Containers provide the ability to package, deploy and reuse applications using a natural isolation boundary. Developers can expose application-specific functionality as interfaces as well as more generic hooks for many systems like metrics, health, etc.</p><p>In this paper the authors present the readers with two types of container design patterns: Patterns for container in the same machine (Single node) and patterns where the containers are spread out in different machines (multi node)</p><h4 id=single-node-patterns>Single Node Patterns<a hidden class=anchor aria-hidden=true href=#single-node-patterns>#</a></h4><p><em><strong>Sidecar Pattern</strong></em></p><p>Sidecar patterns extend and enhance the main container. A webserver container and logger running alongside in the same machine is a common example.
Developers could package the whole application as a single container but separating them brings advantages:</p><ul><li>A container is a single unit of allocation for thinking about resource consumptions</li><li>A container is a unit of packaging for dependency management. You can implement your server and logger in different languages or usind different versions of the same libraries</li><li>A container is a unit of reuse. You can write your logger once and reuse it in other applications.</li><li>A container provides a single <em>failure boundary</em> making it possible to degrade gracefully</li><li>A container is a unit of deployment, which allows each piece of functionality to be upgraded and rolled back idependently</li></ul><p><em><strong>Ambassador Pattern</strong></em></p><p>Ambassador containers proxy communication to and from a main containers. For example a developer could be writing an application that send data to different services located in different network namespaces the ambassador provides a simple interface to the container to hide away the details of routing request to the appropriate destination.</p><p><em><strong>Adapter Pattern</strong></em></p><p>Adapters present the outside world with a simplified, consistent view of an application for example, exposing metrics to the outside world. It&rsquo;s the opposite of the ambassador pattern in the sense that it simplifies the view of the container to the system.</p><h4 id=multi-node-patterns>Multi Node Patterns<a hidden class=anchor aria-hidden=true href=#multi-node-patterns>#</a></h4><p><em><strong>Leader election pattern</strong></em></p><p>Leader election is a common functionality when replication is used.</p><p><em><strong>Work queue pattern</strong></em></p><p>With containers it should be straight forward to build systems that can act as a generic work queue.</p><p><em><strong>Scatter/Gather</strong></em></p><p>Map reduce is an example of this. Clients configure a job, you have one container in charge of sending out work to be done in parallel and the mapper gathers all the results and reduces it down to a single results. This pattern can be applied to many big data applications.</p><p>Personally, I have seen the sidecar, ambassador and adapter pattern a lot but I think the multi-node patterns are examples of things that get implemented once and then become part of the infrastructure, there are multiple systems that implement work queues, leader election and scatter gather, so there is no need to re-implement it when somebody probably has done a better job.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://JoseVillalta.github.io/>Yes Way Jose</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>